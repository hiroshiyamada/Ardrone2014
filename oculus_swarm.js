/*********************************
 * 12/21 (mentos,yamaD)
 * 色素材はクロマキー用のブルーシートを使用する，本番はマントとして身にまとう
 * HSVのThresholdを青色用に変更
 * 不要コードを削除した
 * drone.moveにdroneControlを移した
 * 単振動するプログラムを実装
 * 挙動はやる度によって変わるが，うまくいくときもある
 *
 * To Do
 * HSVのThresholdの見直し
 * drone.frontやdrone.backの引数値見直し
 ********************************/

// Generated by CoffeeScript 1.8.0
(function() {
	var ardrone, swarm, _;
	var drone;
	var face = null;
	var cameraWidth = 640;
	var cameraHeight = 360;
	var cv = require('opencv');
	var global_image;
	var centerPoint = [0, 0, 0];

	//for PID_ctrl
	var prevDiff = 0;
	var integratedDiff = 0;

	_ = require("underscore");

	ardrone = require("ar-drone");

	swarm = [];

	swarm.drones = {};

	swarm.forEach = function(iterator) {
		return Object.keys(swarm.drones).forEach(function(id) {
			return iterator(swarm.drones[id]);
		});
	};

	swarm["do"] = function(block) {
		return swarm.forEach(function(drone) {
			return typeof block === "function" ? block(drone) :
			void 0;
		});
	};

	swarm.action = function(command) {
		return swarm.forEach(function(drone) {
			var _name;
			if (drone.enabled) {
				drone.snooze(drone.inactivityTime);
				//console.log("drone[" + command.action + "]()");
				return typeof drone[ _name = command.action] === "function" ? drone[_name]() :
				void 0;
			}
		});
	};

	swarm.move = function(control) {
		return swarm.forEach(function(drone) {
			if (drone.enabled) {
				drone.snooze(drone.inactivityTime);
				return drone.move(control);
			}
		});
	};

	swarm.animate = function(animation) {
		return swarm.forEach(function(drone) {
			if (drone.enabled) {
				drone.snooze(animation.duration);
				return drone.animate(animation.name, animation.duration);
			}
		});
	};

	swarm.png = function() {
		return swarm.forEach(function(drone) {
			if (drone.enabled) {
				console.log('Creating png stream ...');
				var pngStream = drone.getPngStream();
				var lastPng;
				pngStream.on('error', console.log).on('data', function(pngBuffer) {
					console.log('Getting png stream ...');
					lastPng = pngBuffer;
					cv.readImage(lastPng, function(err, im) {
						//var centerPoint;
						centerPoint = colorDetect(im);
						console.log(" x = " + centerPoint[0] + " y = " + centerPoint[1]);
						global_image = im;
						im.save('../out.jpg');
						//droneControl(im, centerPoint);
					})
				});
			}
		});
	}
	function PID_ctrl(diff) {
		var ret;
		var kp = 0.5;
		var ki = 0;
		var kd = 0.1;
		//pid control
		integratedDiff += diff;
		ret = kp * diff + kd * (diff - prevDiff) + ki * integratedDiff;
		prevDiff = diff;
		//make return value -1.0 ~ 1.0
		if (ret > 1.0) {
			ret = 1.0;
		} else if (ret < -1.0) {
			ret = -1.0;
		}
		return ret;
	}

	function wait() {
		var time1 = new Date().getTime();
		var time2 = new Date().getTime();
		while ((time2 - time1) < 100) {
			time2 = new Date().getTime();
		}
	}

	var droneCount = 0;
	// callback function for control
	function droneControl(image, centerPoint) {

		var countUpperThreshold = cameraWidth * cameraHeight / 8 / 8;
		var countMiddleThreshold = cameraWidth * cameraHeight / 10 / 10;
		var countLowerThreshold = cameraWidth * cameraHeight / 30 / 30;
		var diff_x = (centerPoint[0] - cameraWidth / 2) / (cameraWidth / 2);
		// -1.0 ~ 1.0
		var diff_y = (centerPoint[1] - cameraHeight / 2) / (cameraHeight / 2);
		// -1.0 ~ 1.0
		var diff_z = (centerPoint[2] - countMiddleThreshold) / (countMiddleThreshold);
		// -1.0 ~ 1.0
		var ctrl_x = PID_ctrl(diff_x);
		var ctrl_y = PID_ctrl(diff_y);
		var ctrl_z = PID_ctrl(diff_z);

		//pid control
		if (centerPoint[2] < 10) {
			console.log("stop");
			drone.stop();
		} else {
			if (droneCount == 0) {
				if (Math.abs(diff_x) < 0.3 && Math.abs(diff_y) < 0.3) {
					if (ctrl_z >= 0) {
						console.log("back");
						console.log("ctrl_z=" + ctrl_z);
						drone.back(ctrl_z * 0.2);
					} else {
						console.log("front");
						console.log("ctrl_z=" + ctrl_z);
						drone.front(Math.abs(ctrl_z * 0.2));
					}
				}
				droneCount = 1;
			} else {
				//pid control
				if (ctrl_x >= 0) {
					console.log("right");
					console.log("ctrl_x=" + ctrl_x);
					drone.right(ctrl_x * 0.5);
				} else {
					console.log("left");
					console.log("ctrl_x=" + ctrl_x);
					drone.left(Math.abs(ctrl_x * 0.5));
				}
				droneCount = 0;
			}
		}
		/*
		 if ( centerPoint[2] > countUpperThreshold) {

		 drone.back(0.5);
		 //wait();
		 console.log("back");
		 console.log(centerPoint[2]);
		 } else if ( centerPoint[2] > countMiddleThreshold ){
		 drone.stop();
		 //wait();
		 console.log("stay");
		 console.log(centerPoint[2]);
		 } else if ( centerPoint[2] > countLowerThreshold) {
		 drone.front(0.5);
		 //wait();
		 console.log("front");
		 console.log(centerPoint[2]);
		 } else {
		 drone.stop();
		 //wait();
		 console.log("stop : nothing found");
		 console.log(centerPoint[2]);
		 }
		 // im.saveがないと何故かセグフォることがある*/

	}

	// BGR threshold for red detection
	// var lower_threshold = [0, 0, 150]; // RGB
	var lower_threshold = [100, 128, 60];
	// HSV
	//var upper_threshold = [150, 150, 255]; // RGB
	var upper_threshold = [150, 255, 255];
	//HSV

	// color detection
	function colorDetect(image) {
		var count = 0;
		var xCount = 0;
		var yCount = 0;
		var middleX = 0;
		//add to initialize
		var middleY = 0;
		//add to initialize
		var threshold = 360 * 640 / (40 * 40);
		//if threshold is smaller than the size of screen, drone wont move

		//HSV
		image.convertHSVscale();

		image.inRange(lower_threshold, upper_threshold);
		//filter colors
		image.save('./color_detection.jpg');
		for (var i = 0; i < image.height(); i += 5) {
			for (var j = 0; j < image.width(); j += 5) {
				if (isNaN(image.get(i, j))) {
					count++;
					xCount += j;
					yCount += i;
				}
			}
		}
		//console.log("count = " + count + ",xCount = " + xCount + ",yCount = " + yCount);
		if (count > threshold) {
			middleX = xCount / count;
			middleY = yCount / count;
		}
		//console.log(" x = " + middleX + " y = " + middleY);
		local_centerPoint = [middleX, middleY, count];
		return local_centerPoint;
	}


	swarm.add = function(config) {
		drone = ardrone.createClient({
			ip : config.ip
		});
		drone.id = config.id || config.ip.split(".").pop();
		drone.ip = config.ip;
		drone.enabled = true;
		drone.camera = 1;
		drone.changeCamera = function(camera) {
			if (camera === "toggle") {
				camera = !drone.camera + 0;
			}
			if ( typeof camera !== "number") {
				camera = 0;
			}
			drone.config('video:video_channel', '' + camera);
			return drone.camera = camera;
		};
		drone.control = {
			x : 0,
			y : 0,
			z : 0,
			r : 0
		};

		drone.isIddle = function() {
			return drone.control.x === 0 && drone.control.y === 0 && drone.control.z === 0 && drone.control.r === 0;
		};
		drone.move = function(control) {
			droneControl(global_image, centerPoint);
			return control;
		};
		drone.inactivityTime = 200;
		drone.inactivityTimeout = +(new Date) + drone.inactivityTime;
		drone.snooze = function(length) {
			if (drone.inactive) {
				console.log("drone %s snooze (keep alive off)", drone.ip);
			}
			drone.inactive = false;
			return drone.inactivityTimeout = +(new Date) + length;
		};
		drone.keepAlive = function() {
			if (+new Date() > drone.inactivityTimeout) {
				if (!drone.inactive) {
					console.log("drone %s inactive (keep alive on)", drone.ip);
				}
				drone.inactive = true;
				return drone.move();
			}
		};
		setInterval(drone.keepAlive, 15);
		swarm.drones[drone.id] = drone;
		return swarm.push(drone);
	};

	module.exports = swarm;

}).call(this); 