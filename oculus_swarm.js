/*********************************
 * 12/21 (mentos,yamaD)
 * 色素材はクロマキー用のブルーシートを使用する，本番はマントとして身にまとう
 * HSVのThresholdを青色用に変更
 * 不要コードを削除した
 * drone.moveにdroneControlを移した
 * 単振動するプログラムを実装
 * 挙動はやる度によって変わるが，うまくいくときもある
 * 
 * To Do
 * HSVのThresholdの見直し
 * drone.frontやdrone.backの引数値見直し
 ********************************/

// Generated by CoffeeScript 1.8.0
(function() {
  var ardrone, swarm, _;
  var drone;
  var face = null;
  var cameraWidth = 640;
  var cameraHeight = 360;
  var cv = require('opencv');
  var global_image;
  var centerPoint = [0,0,0];

    //for PID_ctrl
    var prevDiff = 0;
    var integratedDiff;
    
  _ = require("underscore");
  
  ardrone = require("ar-drone");

  swarm = [];

  swarm.drones = {};

  swarm.forEach = function(iterator) {
    return Object.keys(swarm.drones).forEach(function(id) {
      return iterator(swarm.drones[id]);
    });
  };

  swarm["do"] = function(block) {
    return swarm.forEach(function(drone) {
      return typeof block === "function" ? block(drone) : void 0;
    });
  };

  swarm.action = function(command) {
    return swarm.forEach(function(drone) {
      var _name;
      if (drone.enabled) {
        drone.snooze(drone.inactivityTime);
        //console.log("drone[" + command.action + "]()");
        return typeof drone[_name = command.action] === "function" ? drone[_name]() : void 0;
      }
    });
  };

  swarm.move = function(control) {
    return swarm.forEach(function(drone) {
      if (drone.enabled) {
        drone.snooze(drone.inactivityTime);
        return drone.move(control);
      }
    });
  };

  swarm.animate = function(animation) {
    return swarm.forEach(function(drone) {
      if (drone.enabled) {
        drone.snooze(animation.duration);
        return drone.animate(animation.name, animation.duration);
      }
    });
  };
  
  swarm.png = function() {
    return swarm.forEach(function(drone) {
      if (drone.enabled) {
        console.log('Creating png stream ...');
        var pngStream = drone.getPngStream();
        var lastPng;
        pngStream.on('error', console.log).on('data', function(pngBuffer) {
          console.log('Getting png stream ...');
          lastPng = pngBuffer;
          cv.readImage(lastPng, function(err, im) {
            //var centerPoint;
            centerPoint = colorDetect(im); 
            console.log(" x = " + centerPoint[0] + " y = " + centerPoint[1]);
            global_image = im;
            im.save('../out.jpg');
            //droneControl(im, centerPoint);
          })
        });
      }
    });
  }
  
    function PID_ctrl(diff){
        var ret;
        var kp = 1;
        ret = kp*diff;
        return Math.abs(ret) /* / Math.abs(retMax) */  ; //◀︎semicolonあります
    }
    
    function wait (){
        var time1 = new Date().getTime();
        var time2 = new Date().getTime();
    
        while ((time2 -  time1)<100){
            time2 = new Date().getTime();
        }
    }

  // callback function for control
    function droneControl(image,centerPoint){
        
        var diff_x  = (centerPoint[0] - cameraWidth/2) / (cameraWidth/2); // -1.0 ~ 1.0
        var diff_y  = (centerPoint[1] - cameraHeight/2) / (cameraHeight/2);
        var ctrl_x = PID_ctrl(diff_x);
        var ctrl_y = PID_ctrl(diff_y);
        var countUpperThreshold = cameraWidth * cameraHeight / 8 / 8;
        var countMiddleThreshold = cameraWidth * cameraHeight / 25 / 25;
        var countLowerThreshold = cameraWidth * cameraHeight / 30 / 30;
            
        if ( centerPoint[2] > countUpperThreshold) {
          
            drone.back(0.05);
            //wait();
            console.log("back");
            console.log(centerPoint[2]);
        } else if ( centerPoint[2] > countMiddleThreshold ){
            drone.stop();
            //wait();
            console.log("stay");
            console.log(centerPoint[2]);
        } else if ( centerPoint[2] > countLowerThreshold) {
            drone.front(0.05);
            //wait();
            console.log("front");
            console.log(centerPoint[2]);
        } else {
            drone.stop();
            //wait();            
            console.log("stop : nothing found");
            console.log(centerPoint[2]);
        }
        // im.saveがないと何故かセグフォることがある
        
    }
  
  
  // BGR threshold for red detection
  // var lower_threshold = [0, 0, 150]; // RGB
  var lower_threshold = [100, 128, 128]; // HSV
  //var upper_threshold = [150, 150, 255]; // RGB
  var upper_threshold = [150, 255, 255]; //HSV
 
  // color detection
  function colorDetect(image) {
    var count = 0;
    var xCount = 0;
    var yCount = 0;
    var middleX = 0;//add to initialize
    var middleY = 0;//add to initialize
    var threshold = 360 * 640 / (40 * 40); //if threshold is smaller than the size of screen, drone wont move
    
    
    //HSV
    image.convertHSVscale();
    
    image.inRange(lower_threshold, upper_threshold);    //filter colors
    image.save('./color_detection.jpg');
    for(var i = 0; i < image.height(); i+=5){
        for (var j = 0; j < image.width(); j+=5){
            if(isNaN(image.get(i,j))){
                count++;
                xCount+=j;
                yCount+=i;
            }
        }
    }
    //console.log("count = " + count + ",xCount = " + xCount + ",yCount = " + yCount);
    if(count > threshold){
        middleX = xCount / count;
        middleY = yCount / count;
    }
    //console.log(" x = " + middleX + " y = " + middleY);
    local_centerPoint = [middleX, middleY, count];
    return local_centerPoint;
  }  

  swarm.add = function(config) {
    drone = ardrone.createClient({
      ip: config.ip
    });
    drone.id = config.id || config.ip.split(".").pop();
    drone.ip = config.ip;
    drone.enabled = true;
    drone.camera = 1;
    drone.changeCamera = function(camera) {
      if (camera === "toggle") {
        camera = !drone.camera + 0;
      }
      if (typeof camera !== "number") {
        camera = 0;
      }
      drone.config('video:video_channel', '' + camera);
      return drone.camera = camera;
    };
    drone.control = {
      x: 0,
      y: 0,
      z: 0,
      r: 0
    };
    
    drone.isIddle = function() {
      return drone.control.x === 0 && drone.control.y === 0 && drone.control.z === 0 && drone.control.r === 0;
    };
    drone.move = function(control) {
        droneControl(global_image, centerPoint);
        return control;
    };
    drone.inactivityTime = 200;
    drone.inactivityTimeout = +(new Date) + drone.inactivityTime;
    drone.snooze = function(length) {
      if (drone.inactive) {
        console.log("drone %s snooze (keep alive off)", drone.ip);
      }
      drone.inactive = false;
      return drone.inactivityTimeout = +(new Date) + length;
    };
    drone.keepAlive = function() {
      if (+new Date() > drone.inactivityTimeout) {
        if (!drone.inactive) {
          console.log("drone %s inactive (keep alive on)", drone.ip);
        }
        drone.inactive = true;
        return drone.move();
      }
    };
    setInterval(drone.keepAlive, 15);
    swarm.drones[drone.id] = drone;
    return swarm.push(drone);
  };

  module.exports = swarm;

}).call(this);